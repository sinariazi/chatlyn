"use server"

import { generateText } from "ai"
import prisma from "@/lib/db"
import type { Message, Conversation } from "@prisma/client"
import {
  trackRuleTriggered,
  trackRuleExecuted,
  trackAISuggestionUsed,
} from "@/lib/analytics/trackEvent"

export interface RuleCondition {
  type: "keyword" | "contains" | "startsWith" | "endsWith" | "regex"
  value: string
  caseSensitive?: boolean
}

export interface RuleAction {
  type: "ai_reply" | "template_reply" | "tag" | "escalate"
  template?: string
  tagName?: string
}

interface EvaluationResult {
  ruleId: string
  ruleName: string
  matched: boolean
  actionsExecuted: string[]
  generatedReply?: string
  error?: string
}

interface MessageWithConversation extends Message {
  conversation: Conversation
}

function matchesCondition(content: string, condition: RuleCondition): boolean {
  const text = condition.caseSensitive ? content : content.toLowerCase()
  const value = condition.caseSensitive ? condition.value : condition.value.toLowerCase()

  switch (condition.type) {
    case "keyword":
    case "contains":
      return text.includes(value)
    case "startsWith":
      return text.startsWith(value)
    case "endsWith":
      return text.endsWith(value)
    case "regex":
      try {
        const regex = new RegExp(condition.value, condition.caseSensitive ? "" : "i")
        return regex.test(content)
      } catch {
        return false
      }
    default:
      return false
  }
}

async function executeAIReply(
  message: MessageWithConversation
): Promise<string | null> {
  try {
    const messages = await prisma.message.findMany({
      where: { conversationId: message.conversationId },
      orderBy: { createdAt: "asc" },
      take: 10,
    })

    const conversationHistory = messages
      .map((msg) => {
        const role = msg.direction === "INCOMING" ? "Guest" : "Staff"
        return `${role}: ${msg.content}`
      })
      .join("\n")

    const { text } = await generateText({
      model: "openai/gpt-4o-mini",
      system: `You are a professional hospitality assistant. Generate a helpful, warm, and concise reply to the guest. Keep it to 2-3 sentences.`,
      prompt: `Conversation on ${message.channel.toLowerCase()} channel:\n\n${conversationHistory}\n\nGenerate an appropriate reply:`,
      maxOutputTokens: 200,
    })

    return text?.trim() || null
  } catch (error) {
    console.error("AI reply generation failed:", error)
    return null
  }
}

async function executeTemplateReply(
  template: string,
  message: MessageWithConversation
): Promise<string> {
  return template
    .replace(/\{\{channel\}\}/g, message.channel.toLowerCase())
    .replace(/\{\{contactId\}\}/g, message.conversation.contactId)
    .replace(/\{\{subject\}\}/g, message.conversation.subject || "your inquiry")
}

export async function evaluateRulesForMessage(
  messageId: string
): Promise<EvaluationResult[]> {
  const results: EvaluationResult[] = []

  const message = await prisma.message.findUnique({
    where: { id: messageId },
    include: { conversation: true },
  })

  if (!message || message.direction !== "INCOMING") {
    return results
  }

  const activeRules = await prisma.rule.findMany({
    where: {
      isActive: true,
      trigger: { in: ["MESSAGE_RECEIVED", "KEYWORD_MATCH"] },
    },
    orderBy: { priority: "desc" },
  })

  for (const rule of activeRules) {
    const conditions = rule.conditions as RuleCondition[]
    const actions = rule.actions as RuleAction[]

    const allConditionsMatch = conditions.every((condition) =>
      matchesCondition(message.content, condition)
    )

    if (!allConditionsMatch) {
      results.push({
        ruleId: rule.id,
        ruleName: rule.name,
        matched: false,
        actionsExecuted: [],
      })
      continue
    }

    // Track rule triggered event
    await trackRuleTriggered(
      message.conversationId,
      rule.id,
      rule.name,
      messageId
    )

    const executedActions: string[] = []
    let generatedReply: string | undefined
    let error: string | undefined

    for (const action of actions) {
      try {
        switch (action.type) {
          case "ai_reply": {
            const reply = await executeAIReply(message)
            if (reply) {
              await prisma.message.create({
                data: {
                  conversationId: message.conversationId,
                  channel: message.channel,
                  direction: "OUTGOING",
                  content: reply,
                  contentType: "TEXT",
                  metadata: { autoGenerated: true, ruleId: rule.id },
                },
              })
              generatedReply = reply
              executedActions.push("ai_reply")

              // Track AI suggestion used via rule
              await trackAISuggestionUsed(
                message.conversationId,
                reply,
                "rule"
              )
            }
            break
          }

          case "template_reply": {
            if (action.template) {
              const reply = await executeTemplateReply(action.template, message)
              await prisma.message.create({
                data: {
                  conversationId: message.conversationId,
                  channel: message.channel,
                  direction: "OUTGOING",
                  content: reply,
                  contentType: "TEXT",
                  metadata: { autoGenerated: true, ruleId: rule.id, template: true },
                },
              })
              generatedReply = reply
              executedActions.push("template_reply")
            }
            break
          }

          case "tag": {
            executedActions.push(`tag:${action.tagName}`)
            break
          }

          case "escalate": {
            await prisma.conversation.update({
              where: { id: message.conversationId },
              data: { status: "PENDING" },
            })
            executedActions.push("escalate")
            break
          }
        }
      } catch (err) {
        error = err instanceof Error ? err.message : "Action failed"
      }
    }

    // Track rule executed event
    await trackRuleExecuted(
      message.conversationId,
      rule.id,
      rule.name,
      executedActions
    )

    results.push({
      ruleId: rule.id,
      ruleName: rule.name,
      matched: true,
      actionsExecuted: executedActions,
      generatedReply,
      error,
    })

    if (generatedReply) {
      break
    }
  }

  return results
}

export async function simulateIncomingMessage(
  conversationId: string,
  content: string
): Promise<{ messageId: string; ruleResults: EvaluationResult[] }> {
  const conversation = await prisma.conversation.findUnique({
    where: { id: conversationId },
  })

  if (!conversation) {
    throw new Error("Conversation not found")
  }

  const message = await prisma.message.create({
    data: {
      conversationId,
      channel: conversation.channel,
      direction: "INCOMING",
      content,
      contentType: "TEXT",
    },
  })

  await prisma.event.create({
    data: {
      type: "MESSAGE_RECEIVED",
      conversationId,
      payload: { messageId: message.id },
    },
  })

  const ruleResults = await evaluateRulesForMessage(message.id)

  return { messageId: message.id, ruleResults }
}
